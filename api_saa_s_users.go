/*
External API

## Date type fields API endpoints expected date in UTCÂ±0:00 timezone. Timezones in ISO8601 format will be ignored. API endpoints support date in two formats (one of): ISO8601 ('YYYY-MM-DDTHH:mm:SSZ') or Unix Timestamp (seconds count since January 1st, 1970 at UTC).  ## Dropdown fields Some fields are configured as dropdown fields with a dedicated list of values within Oomnitza. You can review the list of available dropdown values within the customization page in Oomnitza. In case you want to be able to post any data into these fields, you should switch them to dropdown without value within the customization page. 

API version: 3.0.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package oomnitza

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// SaaSUsersApiService SaaSUsersApi service
type SaaSUsersApiService service

type ApiApiV3SaasIdentRolesGetRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	ident string
}

func (r ApiApiV3SaasIdentRolesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3SaasIdentRolesGetExecute(r)
}

/*
ApiV3SaasIdentRolesGet Method for ApiV3SaasIdentRolesGet

Gets SaaS Roles list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3SaasIdentRolesGetRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesGet(ctx context.Context, ident string) ApiApiV3SaasIdentRolesGetRequest {
	return ApiApiV3SaasIdentRolesGetRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesGetExecute(r ApiApiV3SaasIdentRolesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasIdentRolesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas/{ident}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3SaasIdentRolesPostRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	ident string
	saaSCreateRoleObject *SaaSCreateRoleObject
}

func (r ApiApiV3SaasIdentRolesPostRequest) SaaSCreateRoleObject(saaSCreateRoleObject SaaSCreateRoleObject) ApiApiV3SaasIdentRolesPostRequest {
	r.saaSCreateRoleObject = &saaSCreateRoleObject
	return r
}

func (r ApiApiV3SaasIdentRolesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3SaasIdentRolesPostExecute(r)
}

/*
ApiV3SaasIdentRolesPost Method for ApiV3SaasIdentRolesPost

Create SaaS Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3SaasIdentRolesPostRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesPost(ctx context.Context, ident string) ApiApiV3SaasIdentRolesPostRequest {
	return ApiApiV3SaasIdentRolesPostRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesPostExecute(r ApiApiV3SaasIdentRolesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasIdentRolesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas/{ident}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.saaSCreateRoleObject
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3SaasIdentRolesSaasRoleIdDeleteRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	ident string
	saasRoleId string
}

func (r ApiApiV3SaasIdentRolesSaasRoleIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3SaasIdentRolesSaasRoleIdDeleteExecute(r)
}

/*
ApiV3SaasIdentRolesSaasRoleIdDelete Method for ApiV3SaasIdentRolesSaasRoleIdDelete

Delete SaaS Role and Users relations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @param saasRoleId ID of SaaS Role
 @return ApiApiV3SaasIdentRolesSaasRoleIdDeleteRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesSaasRoleIdDelete(ctx context.Context, ident string, saasRoleId string) ApiApiV3SaasIdentRolesSaasRoleIdDeleteRequest {
	return ApiApiV3SaasIdentRolesSaasRoleIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
		saasRoleId: saasRoleId,
	}
}

// Execute executes the request
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesSaasRoleIdDeleteExecute(r ApiApiV3SaasIdentRolesSaasRoleIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasIdentRolesSaasRoleIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas/{ident}/roles/{saas_role_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_role_id"+"}", url.PathEscape(parameterToString(r.saasRoleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3SaasIdentRolesSaasRoleIdPatchRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	ident string
	saasRoleId string
	saaSEditRoleObject *SaaSEditRoleObject
}

func (r ApiApiV3SaasIdentRolesSaasRoleIdPatchRequest) SaaSEditRoleObject(saaSEditRoleObject SaaSEditRoleObject) ApiApiV3SaasIdentRolesSaasRoleIdPatchRequest {
	r.saaSEditRoleObject = &saaSEditRoleObject
	return r
}

func (r ApiApiV3SaasIdentRolesSaasRoleIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3SaasIdentRolesSaasRoleIdPatchExecute(r)
}

/*
ApiV3SaasIdentRolesSaasRoleIdPatch Method for ApiV3SaasIdentRolesSaasRoleIdPatch

Update SaaS Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @param saasRoleId ID of SaaS Role
 @return ApiApiV3SaasIdentRolesSaasRoleIdPatchRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesSaasRoleIdPatch(ctx context.Context, ident string, saasRoleId string) ApiApiV3SaasIdentRolesSaasRoleIdPatchRequest {
	return ApiApiV3SaasIdentRolesSaasRoleIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
		saasRoleId: saasRoleId,
	}
}

// Execute executes the request
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesSaasRoleIdPatchExecute(r ApiApiV3SaasIdentRolesSaasRoleIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasIdentRolesSaasRoleIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas/{ident}/roles/{saas_role_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_role_id"+"}", url.PathEscape(parameterToString(r.saasRoleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.saaSEditRoleObject
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3SaasIdentRolesUsersDeleteRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	ident string
}

func (r ApiApiV3SaasIdentRolesUsersDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3SaasIdentRolesUsersDeleteExecute(r)
}

/*
ApiV3SaasIdentRolesUsersDelete Method for ApiV3SaasIdentRolesUsersDelete

Unassign users from the SaaS Roles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3SaasIdentRolesUsersDeleteRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesUsersDelete(ctx context.Context, ident string) ApiApiV3SaasIdentRolesUsersDeleteRequest {
	return ApiApiV3SaasIdentRolesUsersDeleteRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesUsersDeleteExecute(r ApiApiV3SaasIdentRolesUsersDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasIdentRolesUsersDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas/{ident}/roles/users"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3SaasIdentRolesUsersPatchRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	ident string
	usersSaaSRoleUpdateListObject *UsersSaaSRoleUpdateListObject
}

func (r ApiApiV3SaasIdentRolesUsersPatchRequest) UsersSaaSRoleUpdateListObject(usersSaaSRoleUpdateListObject UsersSaaSRoleUpdateListObject) ApiApiV3SaasIdentRolesUsersPatchRequest {
	r.usersSaaSRoleUpdateListObject = &usersSaaSRoleUpdateListObject
	return r
}

func (r ApiApiV3SaasIdentRolesUsersPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3SaasIdentRolesUsersPatchExecute(r)
}

/*
ApiV3SaasIdentRolesUsersPatch Method for ApiV3SaasIdentRolesUsersPatch

Assign users to the SaaS Roles. Overwrites the current list of the User's roles in this certain SaaS. If new Role values come in the list than new SaaSRole records will be created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3SaasIdentRolesUsersPatchRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesUsersPatch(ctx context.Context, ident string) ApiApiV3SaasIdentRolesUsersPatchRequest {
	return ApiApiV3SaasIdentRolesUsersPatchRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesUsersPatchExecute(r ApiApiV3SaasIdentRolesUsersPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasIdentRolesUsersPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas/{ident}/roles/users"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.usersSaaSRoleUpdateListObject
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3SaasIdentRolesUsersPostRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	ident string
	usersSaaSRolesListObject *UsersSaaSRolesListObject
}

func (r ApiApiV3SaasIdentRolesUsersPostRequest) UsersSaaSRolesListObject(usersSaaSRolesListObject UsersSaaSRolesListObject) ApiApiV3SaasIdentRolesUsersPostRequest {
	r.usersSaaSRolesListObject = &usersSaaSRolesListObject
	return r
}

func (r ApiApiV3SaasIdentRolesUsersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3SaasIdentRolesUsersPostExecute(r)
}

/*
ApiV3SaasIdentRolesUsersPost Method for ApiV3SaasIdentRolesUsersPost

Assign Users to the SaaS Roles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3SaasIdentRolesUsersPostRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesUsersPost(ctx context.Context, ident string) ApiApiV3SaasIdentRolesUsersPostRequest {
	return ApiApiV3SaasIdentRolesUsersPostRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *SaaSUsersApiService) ApiV3SaasIdentRolesUsersPostExecute(r ApiApiV3SaasIdentRolesUsersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasIdentRolesUsersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas/{ident}/roles/users"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.usersSaaSRolesListObject
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3SaasIdentUsersGetRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	ident string
	lastVisit *string
	roles *string
}

// Filter by last_visit date
func (r ApiApiV3SaasIdentUsersGetRequest) LastVisit(lastVisit string) ApiApiV3SaasIdentUsersGetRequest {
	r.lastVisit = &lastVisit
	return r
}

// Filter by roles. Exclude users where there are no common roles in the list of required roles and list of user roles
func (r ApiApiV3SaasIdentUsersGetRequest) Roles(roles string) ApiApiV3SaasIdentUsersGetRequest {
	r.roles = &roles
	return r
}

func (r ApiApiV3SaasIdentUsersGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3SaasIdentUsersGetExecute(r)
}

/*
ApiV3SaasIdentUsersGet Method for ApiV3SaasIdentUsersGet

Get Users list assigned to the SaaS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3SaasIdentUsersGetRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasIdentUsersGet(ctx context.Context, ident string) ApiApiV3SaasIdentUsersGetRequest {
	return ApiApiV3SaasIdentUsersGetRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *SaaSUsersApiService) ApiV3SaasIdentUsersGetExecute(r ApiApiV3SaasIdentUsersGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasIdentUsersGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas/{ident}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastVisit != nil {
		localVarQueryParams.Add("last_visit", parameterToString(*r.lastVisit, ""))
	}
	if r.roles != nil {
		localVarQueryParams.Add("roles", parameterToString(*r.roles, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3SaasIdentUsersPostRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	ident string
	saaSUserObjectInner *[]SaaSUserObjectInner
}

func (r ApiApiV3SaasIdentUsersPostRequest) SaaSUserObjectInner(saaSUserObjectInner []SaaSUserObjectInner) ApiApiV3SaasIdentUsersPostRequest {
	r.saaSUserObjectInner = &saaSUserObjectInner
	return r
}

func (r ApiApiV3SaasIdentUsersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3SaasIdentUsersPostExecute(r)
}

/*
ApiV3SaasIdentUsersPost Method for ApiV3SaasIdentUsersPost

Bulk assign Users to the SaaS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3SaasIdentUsersPostRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasIdentUsersPost(ctx context.Context, ident string) ApiApiV3SaasIdentUsersPostRequest {
	return ApiApiV3SaasIdentUsersPostRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *SaaSUsersApiService) ApiV3SaasIdentUsersPostExecute(r ApiApiV3SaasIdentUsersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasIdentUsersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas/{ident}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.saaSUserObjectInner
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3SaasIdentUsersUserIdPostRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	ident string
	userId string
	saaSUserManageObject *SaaSUserManageObject
}

func (r ApiApiV3SaasIdentUsersUserIdPostRequest) SaaSUserManageObject(saaSUserManageObject SaaSUserManageObject) ApiApiV3SaasIdentUsersUserIdPostRequest {
	r.saaSUserManageObject = &saaSUserManageObject
	return r
}

func (r ApiApiV3SaasIdentUsersUserIdPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3SaasIdentUsersUserIdPostExecute(r)
}

/*
ApiV3SaasIdentUsersUserIdPost Method for ApiV3SaasIdentUsersUserIdPost

Store user_external_id of user in external saas system

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @param userId ID of User
 @return ApiApiV3SaasIdentUsersUserIdPostRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasIdentUsersUserIdPost(ctx context.Context, ident string, userId string) ApiApiV3SaasIdentUsersUserIdPostRequest {
	return ApiApiV3SaasIdentUsersUserIdPostRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
		userId: userId,
	}
}

// Execute executes the request
func (a *SaaSUsersApiService) ApiV3SaasIdentUsersUserIdPostExecute(r ApiApiV3SaasIdentUsersUserIdPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasIdentUsersUserIdPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas/{ident}/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.saaSUserManageObject
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3SaasUsersActivatePatchRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	inlineRequest *InlineRequest
}

func (r ApiApiV3SaasUsersActivatePatchRequest) InlineRequest(inlineRequest InlineRequest) ApiApiV3SaasUsersActivatePatchRequest {
	r.inlineRequest = &inlineRequest
	return r
}

func (r ApiApiV3SaasUsersActivatePatchRequest) Execute() ([]InlineResponse200, *http.Response, error) {
	return r.ApiService.ApiV3SaasUsersActivatePatchExecute(r)
}

/*
ApiV3SaasUsersActivatePatch Method for ApiV3SaasUsersActivatePatch

Activate Users in the SaaS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3SaasUsersActivatePatchRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasUsersActivatePatch(ctx context.Context) ApiApiV3SaasUsersActivatePatchRequest {
	return ApiApiV3SaasUsersActivatePatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200
func (a *SaaSUsersApiService) ApiV3SaasUsersActivatePatchExecute(r ApiApiV3SaasUsersActivatePatchRequest) ([]InlineResponse200, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasUsersActivatePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas_users/activate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3SaasUsersDeactivatePatchRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	inlineRequest *InlineRequest
}

func (r ApiApiV3SaasUsersDeactivatePatchRequest) InlineRequest(inlineRequest InlineRequest) ApiApiV3SaasUsersDeactivatePatchRequest {
	r.inlineRequest = &inlineRequest
	return r
}

func (r ApiApiV3SaasUsersDeactivatePatchRequest) Execute() ([]InlineResponse200, *http.Response, error) {
	return r.ApiService.ApiV3SaasUsersDeactivatePatchExecute(r)
}

/*
ApiV3SaasUsersDeactivatePatch Method for ApiV3SaasUsersDeactivatePatch

Deactivate Users in the SaaS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3SaasUsersDeactivatePatchRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasUsersDeactivatePatch(ctx context.Context) ApiApiV3SaasUsersDeactivatePatchRequest {
	return ApiApiV3SaasUsersDeactivatePatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200
func (a *SaaSUsersApiService) ApiV3SaasUsersDeactivatePatchExecute(r ApiApiV3SaasUsersDeactivatePatchRequest) ([]InlineResponse200, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasUsersDeactivatePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas_users/deactivate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3SaasUsersGetRequest struct {
	ctx context.Context
	ApiService *SaaSUsersApiService
	filter *string
	text *string
	roles *string
}

// Regular API v3 filter expression
func (r ApiApiV3SaasUsersGetRequest) Filter(filter string) ApiApiV3SaasUsersGetRequest {
	r.filter = &filter
	return r
}

// Regular API v3 full text search expression
func (r ApiApiV3SaasUsersGetRequest) Text(text string) ApiApiV3SaasUsersGetRequest {
	r.text = &text
	return r
}

// Filter by roles. Exclude users where there are no common roles in the list of required roles and list of user roles
func (r ApiApiV3SaasUsersGetRequest) Roles(roles string) ApiApiV3SaasUsersGetRequest {
	r.roles = &roles
	return r
}

func (r ApiApiV3SaasUsersGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3SaasUsersGetExecute(r)
}

/*
ApiV3SaasUsersGet Method for ApiV3SaasUsersGet

Get Users list assigned to the SaaS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3SaasUsersGetRequest
*/
func (a *SaaSUsersApiService) ApiV3SaasUsersGet(ctx context.Context) ApiApiV3SaasUsersGetRequest {
	return ApiApiV3SaasUsersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SaaSUsersApiService) ApiV3SaasUsersGetExecute(r ApiApiV3SaasUsersGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SaaSUsersApiService.ApiV3SaasUsersGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/saas_users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.text != nil {
		localVarQueryParams.Add("text", parameterToString(*r.text, ""))
	}
	if r.roles != nil {
		localVarQueryParams.Add("roles", parameterToString(*r.roles, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization2"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
