/*
External API

## Date type fields API endpoints expected date in UTCÂ±0:00 timezone. Timezones in ISO8601 format will be ignored. API endpoints support date in two formats (one of): ISO8601 ('YYYY-MM-DDTHH:mm:SSZ') or Unix Timestamp (seconds count since January 1st, 1970 at UTC).  ## Dropdown fields Some fields are configured as dropdown fields with a dedicated list of values within Oomnitza. You can review the list of available dropdown values within the customization page in Oomnitza. In case you want to be able to post any data into these fields, you should switch them to dropdown without value within the customization page. 

API version: 3.0.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// StockroomsApiService StockroomsApi service
type StockroomsApiService service

type ApiApiV3StockroomsGetRequest struct {
	ctx context.Context
	ApiService *StockroomsApiService
	limit *string
	skip *string
	sortby *string
	filter string
}

// Limit records
func (r ApiApiV3StockroomsGetRequest) Limit(limit string) ApiApiV3StockroomsGetRequest {
	r.limit = &limit
	return r
}

// Skip records
func (r ApiApiV3StockroomsGetRequest) Skip(skip string) ApiApiV3StockroomsGetRequest {
	r.skip = &skip
	return r
}

// Order for results
func (r ApiApiV3StockroomsGetRequest) Sortby(sortby string) ApiApiV3StockroomsGetRequest {
	r.sortby = &sortby
	return r
}

func (r ApiApiV3StockroomsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3StockroomsGetExecute(r)
}

/*
ApiV3StockroomsGet Method for ApiV3StockroomsGet

Get records list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param filter Regular API v3 filter expression
 @return ApiApiV3StockroomsGetRequest
*/
func (a *StockroomsApiService) ApiV3StockroomsGet(ctx context.Context, filter string) ApiApiV3StockroomsGetRequest {
	return ApiApiV3StockroomsGetRequest{
		ApiService: a,
		ctx: ctx,
		filter: filter,
	}
}

// Execute executes the request
func (a *StockroomsApiService) ApiV3StockroomsGetExecute(r ApiApiV3StockroomsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StockroomsApiService.ApiV3StockroomsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/stockrooms"
	localVarPath = strings.Replace(localVarPath, "{"+"filter"+"}", url.PathEscape(parameterToString(r.filter, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sortby != nil {
		localVarQueryParams.Add("sortby", parameterToString(*r.sortby, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3StockroomsIdentChangesHistoryGetRequest struct {
	ctx context.Context
	ApiService *StockroomsApiService
	ident string
}

func (r ApiApiV3StockroomsIdentChangesHistoryGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3StockroomsIdentChangesHistoryGetExecute(r)
}

/*
ApiV3StockroomsIdentChangesHistoryGet Method for ApiV3StockroomsIdentChangesHistoryGet

Get history changes list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3StockroomsIdentChangesHistoryGetRequest
*/
func (a *StockroomsApiService) ApiV3StockroomsIdentChangesHistoryGet(ctx context.Context, ident string) ApiApiV3StockroomsIdentChangesHistoryGetRequest {
	return ApiApiV3StockroomsIdentChangesHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *StockroomsApiService) ApiV3StockroomsIdentChangesHistoryGetExecute(r ApiApiV3StockroomsIdentChangesHistoryGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StockroomsApiService.ApiV3StockroomsIdentChangesHistoryGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/stockrooms/{ident}/changes-history"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3StockroomsIdentDeleteRequest struct {
	ctx context.Context
	ApiService *StockroomsApiService
	ident string
}

func (r ApiApiV3StockroomsIdentDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3StockroomsIdentDeleteExecute(r)
}

/*
ApiV3StockroomsIdentDelete Method for ApiV3StockroomsIdentDelete

Delete record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3StockroomsIdentDeleteRequest
*/
func (a *StockroomsApiService) ApiV3StockroomsIdentDelete(ctx context.Context, ident string) ApiApiV3StockroomsIdentDeleteRequest {
	return ApiApiV3StockroomsIdentDeleteRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *StockroomsApiService) ApiV3StockroomsIdentDeleteExecute(r ApiApiV3StockroomsIdentDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StockroomsApiService.ApiV3StockroomsIdentDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/stockrooms/{ident}"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3StockroomsIdentGetRequest struct {
	ctx context.Context
	ApiService *StockroomsApiService
	ident string
}

func (r ApiApiV3StockroomsIdentGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3StockroomsIdentGetExecute(r)
}

/*
ApiV3StockroomsIdentGet Method for ApiV3StockroomsIdentGet

Get record details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3StockroomsIdentGetRequest
*/
func (a *StockroomsApiService) ApiV3StockroomsIdentGet(ctx context.Context, ident string) ApiApiV3StockroomsIdentGetRequest {
	return ApiApiV3StockroomsIdentGetRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *StockroomsApiService) ApiV3StockroomsIdentGetExecute(r ApiApiV3StockroomsIdentGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StockroomsApiService.ApiV3StockroomsIdentGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/stockrooms/{ident}"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3StockroomsIdentPatchRequest struct {
	ctx context.Context
	ApiService *StockroomsApiService
	ident string
	oomnitzaIgnoreMetaRestriction *string
	stockroom *Stockroom
}

// Used to allow the non-system edit-only field to be updated. Allowed values: 0, 1
func (r ApiApiV3StockroomsIdentPatchRequest) OomnitzaIgnoreMetaRestriction(oomnitzaIgnoreMetaRestriction string) ApiApiV3StockroomsIdentPatchRequest {
	r.oomnitzaIgnoreMetaRestriction = &oomnitzaIgnoreMetaRestriction
	return r
}

func (r ApiApiV3StockroomsIdentPatchRequest) Stockroom(stockroom Stockroom) ApiApiV3StockroomsIdentPatchRequest {
	r.stockroom = &stockroom
	return r
}

func (r ApiApiV3StockroomsIdentPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3StockroomsIdentPatchExecute(r)
}

/*
ApiV3StockroomsIdentPatch Method for ApiV3StockroomsIdentPatch

Edit record details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3StockroomsIdentPatchRequest
*/
func (a *StockroomsApiService) ApiV3StockroomsIdentPatch(ctx context.Context, ident string) ApiApiV3StockroomsIdentPatchRequest {
	return ApiApiV3StockroomsIdentPatchRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *StockroomsApiService) ApiV3StockroomsIdentPatchExecute(r ApiApiV3StockroomsIdentPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StockroomsApiService.ApiV3StockroomsIdentPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/stockrooms/{ident}"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.oomnitzaIgnoreMetaRestriction != nil {
		localVarHeaderParams["Oomnitza-Ignore-Meta-Restriction"] = parameterToString(*r.oomnitzaIgnoreMetaRestriction, "")
	}
	// body params
	localVarPostBody = r.stockroom
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3StockroomsPostRequest struct {
	ctx context.Context
	ApiService *StockroomsApiService
	oomnitzaIgnoreMetaRestriction *string
	stockroom *Stockroom
}

// Used to allow the non-system edit-only field to be updated. Allowed values: 0, 1
func (r ApiApiV3StockroomsPostRequest) OomnitzaIgnoreMetaRestriction(oomnitzaIgnoreMetaRestriction string) ApiApiV3StockroomsPostRequest {
	r.oomnitzaIgnoreMetaRestriction = &oomnitzaIgnoreMetaRestriction
	return r
}

func (r ApiApiV3StockroomsPostRequest) Stockroom(stockroom Stockroom) ApiApiV3StockroomsPostRequest {
	r.stockroom = &stockroom
	return r
}

func (r ApiApiV3StockroomsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3StockroomsPostExecute(r)
}

/*
ApiV3StockroomsPost Method for ApiV3StockroomsPost

Create record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3StockroomsPostRequest
*/
func (a *StockroomsApiService) ApiV3StockroomsPost(ctx context.Context) ApiApiV3StockroomsPostRequest {
	return ApiApiV3StockroomsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *StockroomsApiService) ApiV3StockroomsPostExecute(r ApiApiV3StockroomsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StockroomsApiService.ApiV3StockroomsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/stockrooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.oomnitzaIgnoreMetaRestriction != nil {
		localVarHeaderParams["Oomnitza-Ignore-Meta-Restriction"] = parameterToString(*r.oomnitzaIgnoreMetaRestriction, "")
	}
	// body params
	localVarPostBody = r.stockroom
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3StockroomsSavedsearchesGetRequest struct {
	ctx context.Context
	ApiService *StockroomsApiService
}

func (r ApiApiV3StockroomsSavedsearchesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3StockroomsSavedsearchesGetExecute(r)
}

/*
ApiV3StockroomsSavedsearchesGet Method for ApiV3StockroomsSavedsearchesGet

Get saved searches list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3StockroomsSavedsearchesGetRequest
*/
func (a *StockroomsApiService) ApiV3StockroomsSavedsearchesGet(ctx context.Context) ApiApiV3StockroomsSavedsearchesGetRequest {
	return ApiApiV3StockroomsSavedsearchesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *StockroomsApiService) ApiV3StockroomsSavedsearchesGetExecute(r ApiApiV3StockroomsSavedsearchesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StockroomsApiService.ApiV3StockroomsSavedsearchesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/stockrooms/savedsearches"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV3StockroomsSavedsearchesIdentGetRequest struct {
	ctx context.Context
	ApiService *StockroomsApiService
	ident string
}

func (r ApiApiV3StockroomsSavedsearchesIdentGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV3StockroomsSavedsearchesIdentGetExecute(r)
}

/*
ApiV3StockroomsSavedsearchesIdentGet Method for ApiV3StockroomsSavedsearchesIdentGet

Get saved search details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ident ID of system object (assets, locations, ...)
 @return ApiApiV3StockroomsSavedsearchesIdentGetRequest
*/
func (a *StockroomsApiService) ApiV3StockroomsSavedsearchesIdentGet(ctx context.Context, ident string) ApiApiV3StockroomsSavedsearchesIdentGetRequest {
	return ApiApiV3StockroomsSavedsearchesIdentGetRequest{
		ApiService: a,
		ctx: ctx,
		ident: ident,
	}
}

// Execute executes the request
func (a *StockroomsApiService) ApiV3StockroomsSavedsearchesIdentGetExecute(r ApiApiV3StockroomsSavedsearchesIdentGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StockroomsApiService.ApiV3StockroomsSavedsearchesIdentGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/stockrooms/savedsearches/{ident}"
	localVarPath = strings.Replace(localVarPath, "{"+"ident"+"}", url.PathEscape(parameterToString(r.ident, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
